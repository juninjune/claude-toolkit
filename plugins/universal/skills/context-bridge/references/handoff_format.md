# Handoff Message Format

This document defines the structure and content of handoff messages generated by context-bridge for seamless session transitions.

## Core Principles

1. **Minimal but Complete**: Include only what's needed to resume work, nothing more
2. **Actionable**: User should know exactly what to do next
3. **Self-contained**: No pronouns like "this", "that", "above code"
4. **Structured**: Consistent format for predictable parsing

## Standard Template

```markdown
## 이전 세션 연속 작업

**세션 기록**: `.dev-journal/[YYYYMMDD_HHMM_topic-slug].md`

### 작업 목표
[1-2 sentence description of overall goal]

### 완료된 작업
- ✅ [Specific completed task 1]
- ✅ [Specific completed task 2]
- ✅ [Specific completed task 3]
(3-5 items max)

### 다음 작업
- [ ] [Next immediate task]
- [ ] [Second priority task]
- [ ] [Third priority task]
(3-5 items max, ordered by priority)

### 주요 결정사항
- [Key decision 1 with rationale]
- [Key decision 2 with rationale]
(1-2 critical decisions only, omit if none)

### 필요한 파일
- `[file/path/1]` - [brief purpose/content description]
- `[file/path/2]` - [brief purpose/content description]
- `[file/path/3]` - [brief purpose/content description]
(3-5 files max, prioritize most relevant)

---

**첫 번째 작업**: [Expanded description of the immediate next task with context]
```

## Section Guidelines

### 작업 목표 (Work Goal)
**Purpose**: Orient the new session to the overall objective

**Good examples**:
- "API 엔드포인트 10개를 리팩토링하여 공통 에러 핸들링 로직과 인증 미들웨어를 적용하는 작업"
- "사용자 대시보드의 성능을 개선하기 위해 데이터 페칭 로직을 최적화하고 불필요한 리렌더링을 제거하는 작업"

**Bad examples**:
- "리팩토링 작업" (too vague)
- "We are refactoring the API endpoints to improve error handling and add authentication middleware, which will make the codebase more maintainable and secure..." (too verbose)

**Rules**:
- 1-2 sentences maximum
- Include WHAT and WHY
- Be specific (mention exact components/features)
- No implementation details

### 완료된 작업 (Completed Work)
**Purpose**: Establish progress baseline, avoid duplicate work

**Good examples**:
- "✅ `UserController`의 모든 메서드에 try-catch 블록 추가 및 `handleApiError()` 적용"
- "✅ 인증 미들웨어 `requireAuth()`를 `/api/users` 엔드포인트에 통합"
- "✅ 에러 응답 타입 정의 `ApiErrorResponse` 인터페이스 생성"

**Bad examples**:
- "✅ 코드 수정함" (not specific)
- "✅ Fixed the bug in the user controller where it wasn't properly handling errors when the database connection failed during user creation..." (too detailed)
- "✅ Completed the implementation" (what implementation?)

**Rules**:
- 3-5 bullet points maximum
- Each item should be a **discrete, verifiable task**
- Include file/component names for context
- Past tense, specific outcomes
- No code snippets

### 다음 작업 (Next Tasks)
**Purpose**: Provide clear roadmap for new session

**Good examples**:
- "[ ] `/api/posts` 엔드포인트에 `handleApiError()` 적용 및 테스트"
- "[ ] `PostController.create()` 메서드에 인증 미들웨어 추가"
- "[ ] 통합 테스트 작성: 인증 실패 시나리오 검증"

**Bad examples**:
- "[ ] 나머지 작업" (not specific)
- "[ ] Continue with the posts endpoint" (what about it?)
- "[ ] Apply error handler to `/api/posts/create`, `/api/posts/update`, `/api/posts/delete`, `/api/posts/:id/comments/create`..." (too many sub-items)

**Rules**:
- 3-5 tasks maximum, **ordered by priority**
- First task = immediate next action
- Each task should be achievable in one focused session
- Action-oriented verbs (적용, 추가, 수정, 테스트, 검증)
- Include file/component names for context

### 주요 결정사항 (Key Decisions)
**Purpose**: Preserve critical context that affects future implementation

**Include ONLY if**:
- Decision significantly impacts architecture/approach
- Reversal would require major refactoring
- Multiple valid options existed (explain why this one was chosen)

**Good examples**:
- "에러 응답 형식을 `{error: string, code: number, details?: any}`로 표준화 - 클라이언트 에러 파싱 단순화를 위해"
- "인증 미들웨어를 컨트롤러 레벨이 아닌 라우터 레벨에 적용 - 중복 코드 방지 및 일관성 유지"

**Bad examples**:
- "변수명을 `err`에서 `error`로 변경" (trivial)
- "We decided to use error handling because it's important to handle errors properly..." (obvious)

**Rules**:
- 1-2 decisions maximum (omit section if none)
- Include **rationale** briefly
- Focus on **non-obvious** choices
- No trivial decisions (variable names, formatting, etc.)

### 필요한 파일 (Essential Files)
**Purpose**: Direct user to relevant code without searching

**Good examples**:
- "`src/controllers/UserController.ts` - 리팩토링 완료된 참조 코드"
- "`src/middleware/requireAuth.ts` - 인증 미들웨어 구현"
- "`src/types/api.ts` - API 에러 타입 정의"
- "`tests/integration/auth.test.ts` - 인증 테스트 케이스"

**Bad examples**:
- "`src/` - 소스 코드" (too broad)
- "`package.json`" (no context why it's needed)
- Lists 15 files (too many)

**Rules**:
- 3-5 files maximum
- **Full paths** (not relative)
- Brief description of **why** this file matters
- Prioritize files user will **directly edit** or **reference**
- Omit files that can be found via IDE search

### 첫 번째 작업 (First Task Expansion)
**Purpose**: Provide enough context to start immediately without reading session file

**Good example**:
```
**첫 번째 작업**: `/api/posts` 엔드포인트에 에러 핸들러 적용

`src/controllers/PostController.ts`의 모든 메서드를 `UserController`와 동일한 패턴으로
리팩토링하세요. 각 메서드를 try-catch로 감싸고 `handleApiError(error, res)` 호출.
참조: `UserController.ts:23-45`
```

**Bad example**:
```
**첫 번째 작업**: 다음 엔드포인트 작업
```

**Rules**:
- 2-4 sentences
- Clarify **how** to approach the task
- Reference similar completed work for patterns
- Include file/line numbers if helpful

## Length Guidelines

**Target lengths**:
- Overall message: 250-400 words
- Work goal: 20-40 words
- Completed work: 60-100 words (15-20 per item)
- Next tasks: 60-100 words (15-20 per item)
- Key decisions: 40-80 words (20-40 per item) or omitted
- Essential files: 60-100 words (15-20 per item)
- First task: 40-80 words

**Why these lengths?**
- Short enough to fit in <5% of context window
- Long enough to be actionable without reading session file
- Forces prioritization of essential information

## Examples

### Example 1: API Refactoring (Mid-Progress)

```markdown
## 이전 세션 연속 작업

**세션 기록**: `.dev-journal/20251109_1423_api-error-handling-refactor.md`

### 작업 목표
REST API 엔드포인트 8개에 표준화된 에러 핸들링과 인증 미들웨어를 적용하여 일관된 에러 응답과 보안 강화

### 완료된 작업
- ✅ 공통 에러 핸들러 `handleApiError()` 함수 구현 (`src/utils/errorHandler.ts`)
- ✅ 인증 미들웨어 `requireAuth()` 구현 (`src/middleware/auth.ts`)
- ✅ `UserController` 전체 메서드 리팩토링 완료 (try-catch + error handler 적용)
- ✅ 에러 응답 타입 `ApiErrorResponse` 인터페이스 정의

### 다음 작업
- [ ] `PostController`에 에러 핸들러 적용 (5개 메서드)
- [ ] `CommentController`에 에러 핸들러 적용 (4개 메서드)
- [ ] 모든 엔드포인트에 인증 미들웨어 라우터 레벨 적용
- [ ] 통합 테스트 작성: 인증 실패 및 에러 응답 형식 검증

### 주요 결정사항
- 에러 핸들러를 각 메서드 내부가 아닌 공통 유틸로 분리 - 일관성 유지 및 향후 수정 용이

### 필요한 파일
- `src/controllers/UserController.ts` - 리팩토링 완료된 참조 패턴
- `src/controllers/PostController.ts` - 다음 작업 대상
- `src/utils/errorHandler.ts` - 공통 에러 핸들러
- `src/middleware/auth.ts` - 인증 미들웨어

---

**첫 번째 작업**: `PostController`에 에러 핸들러 적용

`src/controllers/PostController.ts`의 5개 메서드(`create`, `update`, `delete`, `getById`, `getAll`)를
`UserController.ts:23-78`과 동일한 패턴으로 리팩토링하세요. 각 메서드를 try-catch로 감싸고
catch 블록에서 `handleApiError(error, res)` 호출.
```

### Example 2: Bug Fix (Near Completion)

```markdown
## 이전 세션 연속 작업

**세션 기록**: `.dev-journal/20251109_1615_memory-leak-investigation.md`

### 작업 목표
대시보드 페이지에서 발생하는 메모리 누수를 수정하여 장시간 사용 시 브라우저 크래시 방지

### 완료된 작업
- ✅ Chrome DevTools Memory Profiler로 누수 원인 특정: `DataChart` 컴포넌트의 이벤트 리스너 미정리
- ✅ `useEffect` cleanup 함수 추가하여 `resize` 이벤트 리스너 제거
- ✅ `DataChart`의 Chart.js 인스턴스 `.destroy()` 호출 추가

### 다음 작업
- [ ] 동일 패턴으로 `AnalyticsWidget` 컴포넌트 수정 (같은 이슈 존재)
- [ ] 메모리 프로파일링으로 수정 검증 (30분 테스트)

### 필요한 파일
- `src/components/DataChart.tsx` - 수정 완료된 참조 코드
- `src/components/AnalyticsWidget.tsx` - 동일 이슈 존재, 수정 필요

---

**첫 번째 작업**: `AnalyticsWidget` 컴포넌트 메모리 누수 수정

`DataChart.tsx:45-52`와 동일한 패턴으로 `AnalyticsWidget`의 `useEffect`에
cleanup 함수를 추가하세요. 이벤트 리스너와 차트 인스턴스를 정리해야 합니다.
```

### Example 3: Feature Development (Early Stage)

```markdown
## 이전 세션 연속 작업

**세션 기록**: `.dev-journal/20251109_1730_user-notification-system.md`

### 작업 목표
사용자 알림 시스템 구축: 실시간 알림 표시, 읽음/안읽음 상태 관리, 알림 센터 UI

### 완료된 작업
- ✅ 알림 데이터 모델 설계 (`Notification` 타입, Prisma 스키마 업데이트)
- ✅ 백엔드 API 엔드포인트 3개 구현 (생성, 조회, 읽음 처리)
- ✅ 프론트엔드 알림 컨텍스트 및 훅 구현 (`useNotifications`)

### 다음 작업
- [ ] 알림 센터 UI 컴포넌트 구현 (`NotificationCenter.tsx`)
- [ ] 헤더에 알림 벨 아이콘 및 미읽음 카운트 추가
- [ ] WebSocket 연결 설정하여 실시간 알림 푸시
- [ ] 알림 타입별 렌더링 로직 구현 (댓글, 좋아요, 멘션)

### 주요 결정사항
- WebSocket 대신 Server-Sent Events(SSE) 사용 - 단방향 통신으로 충분하며 구현 단순화
- 알림 센터를 모달이 아닌 드롭다운으로 구현 - 빠른 접근성 우선

### 필요한 파일
- `src/contexts/NotificationContext.tsx` - 알림 상태 관리
- `src/hooks/useNotifications.ts` - 알림 훅
- `src/types/notification.ts` - 알림 타입 정의
- `prisma/schema.prisma` - 데이터 모델

---

**첫 번째 작업**: 알림 센터 UI 컴포넌트 구현

`src/components/NotificationCenter.tsx` 파일을 생성하세요.
`useNotifications` 훅으로 알림 목록을 가져와 렌더링하고, 클릭 시 읽음 처리하는
드롭다운 컴포넌트입니다. shadcn/ui의 `DropdownMenu` 사용 권장.
```

## Anti-Patterns to Avoid

### ❌ Too Much Context
```markdown
### 완료된 작업
- ✅ 에러 핸들러를 다음과 같이 구현했습니다:
  ```typescript
  export function handleApiError(error: any, res: Response) {
    // ... 30 lines of code
  }
  ```
  이 함수는 다양한 에러 타입을 처리하며...
```

**Problem**: Code belongs in files, not handoff messages

### ❌ Vague Tasks
```markdown
### 다음 작업
- [ ] 나머지 컨트롤러들 수정
- [ ] 테스트 추가
- [ ] 문서 업데이트
```

**Problem**: Not specific enough to be actionable

### ❌ Too Many Items
```markdown
### 필요한 파일
- `src/controllers/UserController.ts`
- `src/controllers/PostController.ts`
- `src/controllers/CommentController.ts`
- `src/controllers/AdminController.ts`
- `src/utils/errorHandler.ts`
- `src/utils/logger.ts`
- `src/middleware/auth.ts`
- `src/middleware/cors.ts`
- `src/types/api.ts`
- `src/types/user.ts`
- `tests/integration/api.test.ts`
- `tests/unit/errorHandler.test.ts`
```

**Problem**: Defeats purpose of minimal context

### ❌ Missing Context in First Task
```markdown
**첫 번째 작업**: PostController 수정
```

**Problem**: User doesn't know HOW to approach it

## Validation Checklist

Before finalizing a handoff message, verify:

- [ ] Can the user start working **immediately** without reading the session file?
- [ ] Are all tasks **specific** and **actionable**?
- [ ] Is the message under 500 words?
- [ ] Are file paths **complete** (absolute, not relative)?
- [ ] Is the first task **expanded** with enough context?
- [ ] Are there **no pronouns** referencing previous context?
- [ ] Are completed tasks **verifiable** (can user check if it's really done)?
- [ ] Is the session file path **correct**?
